<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ONB Mod File Parser (WASM)</title>
    <style>
        @font-face { 
            font-family: BN6; 
            src: url('https://raw.githubusercontent.com/Keristero/onb-modsite/master/assets/fonts/BN6FontThin.ttf'); 
        }
        @font-face { 
            font-family: BN6;
            font-weight: bold; 
            src: url('https://raw.githubusercontent.com/Keristero/onb-modsite/master/assets/fonts/BN6FontBold.ttf'); 
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: BN6, monospace;
            background-color: lightblue;
            image-rendering: pixelated;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            box-shadow: 2px 5px 10px rgba(0, 0, 0, 0.287);
            max-width: 800px;
            width: 100%;
            overflow: hidden;
        }

        .header {
            background-color: rgb(209, 238, 248);
            color: #333;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 0.95em;
        }

        .drop-zone {
            margin: 30px;
            border: 3px dashed rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 60px 30px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.5);
        }

        .drop-zone:hover {
            border-color: rgba(0, 0, 0, 0.5);
            background: rgba(255, 255, 255, 0.7);
        }

        .drop-zone.drag-over {
            border-color: rgba(0, 0, 0, 0.7);
            background: rgba(209, 238, 248, 0.5);
            transform: scale(1.02);
        }

        .drop-zone-icon {
            font-size: 3em;
            margin-bottom: 15px;
        }

        .drop-zone-text {
            color: #333;
            font-size: 1.1em;
            font-weight: bold;
        }

        .drop-zone-hint {
            color: #888;
            font-size: 0.9em;
            margin-top: 10px;
        }

        .output {
            margin: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            display: none;
            box-shadow: 2px 5px 10px rgba(0, 0, 0, 0.287);
        }

        .output.visible {
            display: block;
        }

        .output-header {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .output-content {
            background: rgba(0, 0, 0, 0.8);
            color: #d4d4d4;
            padding: 20px;
            border-radius: 6px;
            font-family: BN6, 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.6;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 500px;
            overflow-y: auto;
            position: relative;
        }

        .file-ref {
            color: #4ec9b0;
            text-decoration: underline;
            cursor: pointer;
            position: relative;
        }

        .file-ref:hover {
            color: #6fe9d0;
        }

        .file-ref:active {
            color: #8ffff0;
        }

        .error-line {
            color: #f48771;
            cursor: pointer;
            text-decoration: underline dotted;
        }

        .error-line:hover {
            color: #ff6b6b;
        }

        .tooltip {
            position: fixed;
            background: #2d2d30;
            border: 1px solid #454545;
            border-radius: 6px;
            padding: 10px;
            max-width: 500px;
            max-height: 400px;
            overflow: auto;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            display: none;
        }

        .tooltip.visible {
            display: block;
        }

        .tooltip-image {
            max-width: 100%;
            max-height: 300px;
            display: block;
            margin: 5px 0;
        }

        .tooltip-text {
            color: #d4d4d4;
            font-family: BN6, 'Courier New', monospace;
            font-size: 0.85em;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .tooltip-error {
            color: #ce9178;
            font-size: 0.9em;
        }

        .error-char {
            background: #ff0000;
            color: #fff;
            padding: 0 2px;
            font-weight: bold;
            animation: highlightError 0.6s ease-in-out infinite;
        }

        @keyframes highlightError {
            0%, 100% {
                background: #ff0000;
                box-shadow: 0 0 5px #ff0000;
            }
            50% {
                background: #ff6b6b;
                box-shadow: 0 0 15px #ff6b6b;
            }
        }

        /* Highlight.js overrides for dark theme */
        .hljs {
            background: transparent !important;
            padding: 0 !important;
        }

        .error {
            color: #e74c3c;
            background: rgba(255, 200, 200, 0.5);
            padding: 15px;
            border-radius: 6px;
            margin: 30px;
            display: none;
            box-shadow: 2px 5px 10px rgba(0, 0, 0, 0.287);
        }

        .error.visible {
            display: block;
        }

        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
            display: none;
        }

        .spinner.visible {
            display: block;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .file-input {
            display: none;
        }

        .status {
            text-align: center;
            color: #333;
            font-size: 0.9em;
            padding: 10px;
            margin: 0 30px 20px;
        }

        /* File Browser Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            animation: fadeIn 0.3s ease;
        }

        .modal.visible {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            width: 90%;
            max-width: 1200px;
            height: 80%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .modal-header {
            background-color: rgb(209, 238, 248);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid rgba(0, 0, 0, 0.1);
        }

        .modal-header h2 {
            margin: 0;
            font-size: 1.5em;
            color: #333;
        }

        .modal-close {
            background: rgba(0, 0, 0, 0.1);
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            padding: 5px 15px;
            border-radius: 4px;
            font-family: BN6;
            color: #333;
        }

        .modal-close:hover {
            background: rgba(0, 0, 0, 0.2);
        }

        .modal-body {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .file-browser {
            width: 300px;
            background: rgba(255, 255, 255, 0.7);
            border-right: 2px solid rgba(0, 0, 0, 0.1);
            overflow-y: auto;
            padding: 10px;
        }

        .file-browser-item {
            padding: 8px 12px;
            margin: 2px 0;
            cursor: pointer;
            border-radius: 4px;
            font-size: 0.9em;
            word-break: break-all;
            transition: all 0.2s;
        }

        .file-browser-item:hover {
            background: rgba(209, 238, 248, 0.5);
        }

        .file-browser-item.selected {
            background: rgba(209, 238, 248, 0.8);
            font-weight: bold;
        }

        .file-browser-item.folder {
            color: #666;
            font-weight: bold;
        }

        .file-browser-item.folder::before {
            content: 'üìÅ ';
        }

        .file-browser-item.file::before {
            content: 'üìÑ ';
        }

        .file-preview {
            flex: 1;
            padding: 20px;
            overflow: auto;
            background: rgba(0, 0, 0, 0.05);
        }

        .file-preview-content {
            background: rgba(0, 0, 0, 0.8);
            color: #d4d4d4;
            padding: 20px;
            border-radius: 6px;
            font-family: BN6, 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.6;
            white-space: pre-wrap;
            word-wrap: break-word;
            min-height: 100%;
        }

        .file-preview-image {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
            image-rendering: pixelated;
        }

        .file-preview-empty {
            text-align: center;
            color: #666;
            padding: 50px;
            font-size: 1.1em;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ONB Mod File Parser Alpha</h1>
            <p>Drop a .zip mod file to analyze its contents</p>
        </div>

        <div class="drop-zone" id="dropZone">
            <div class="drop-zone-icon">üì¶</div>
            <div class="drop-zone-text">Drop your .zip file here</div>
            <div class="drop-zone-hint">or click to browse</div>
        </div>

        <input type="file" id="fileInput" class="file-input" accept=".zip">

        <div class="spinner" id="spinner"></div>
        <div class="status" id="status"></div>
        <div class="error" id="error"></div>
        
        <div class="output" id="output">
            <div class="output-header">
                <span>üìÑ</span>
                <span>Analysis Results</span>
            </div>
            <div class="output-content" id="outputContent"></div>
        </div>

        <div class="tooltip" id="tooltip"></div>
    </div>

    <!-- File Browser Modal -->
    <div class="modal" id="fileModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üì¶ File Browser</h2>
                <button class="modal-close" id="modalClose">‚úï</button>
            </div>
            <div class="modal-body">
                <div class="file-browser" id="fileBrowser"></div>
                <div class="file-preview" id="filePreview">
                    <div class="file-preview-empty">Select a file to preview</div>
                </div>
            </div>
        </div>
    </div>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/atom-one-dark.min.css">
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script type="module">
        import { compileStreaming } from './onb_mod_file.mjs';

        let app = null;
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const output = document.getElementById('output');
        const outputContent = document.getElementById('outputContent');
        const errorDiv = document.getElementById('error');
        const spinner = document.getElementById('spinner');
        const status = document.getElementById('status');
        const tooltip = document.getElementById('tooltip');
        const fileModal = document.getElementById('fileModal');
        const modalClose = document.getElementById('modalClose');
        const fileBrowser = document.getElementById('fileBrowser');
        const filePreview = document.getElementById('filePreview');

        let currentZip = null;
        let currentFileName = '';
        let processingWorker = null;
        let workerTimeout = null;

        // Initialize Web Worker
        function initWorker() {
            processingWorker = new Worker('./worker.js', { type: 'module' });
            
            processingWorker.onmessage = function(e) {
                const { type, result, error } = e.data;
                
                if (type === 'init-success') {
                    status.textContent = 'Ready! Drop a file to analyze.';
                } else if (type === 'init-error') {
                    showError('Failed to load WASM module: ' + error);
                } else if (type === 'process-success') {
                    clearTimeout(workerTimeout);
                    handleProcessingResult(result);
                } else if (type === 'process-error') {
                    clearTimeout(workerTimeout);
                    hideSpinner();
                    showError('Error processing file: ' + error);
                }
            };
            
            // Initialize the worker with WASM module
            status.textContent = 'Loading WASM module...';
            processingWorker.postMessage({
                type: 'init',
                data: {
                    wasmUrl: './onb_mod_file.wasm',
                    mjsUrl: './onb_mod_file.mjs'
                }
            });
        }

        function handleProcessingResult(result) {
            hideSpinner();
            
            if (result) {
                outputContent.innerHTML = enhanceOutput(result);
                attachTooltipHandlers();
                output.classList.add('visible');
                status.textContent = 'Analysis complete!';
            } else {
                showError('No output generated from the module');
            }
        }

        function showError(message) {
            errorDiv.textContent = '‚ùå ' + message;
            errorDiv.classList.add('visible');
            output.classList.remove('visible');
            spinner.classList.remove('visible');
        }

        function hideError() {
            errorDiv.classList.remove('visible');
        }

        function showSpinner() {
            spinner.classList.add('visible');
            output.classList.remove('visible');
            hideError();
        }

        function hideSpinner() {
            spinner.classList.remove('visible');
        }

        async function processFile(file) {
            if (!file.name.endsWith('.zip')) {
                showError('Please select a .zip file');
                return;
            }

            hideError();
            showSpinner();
            status.textContent = `Processing ${file.name}...`;

            try {
                // Read file as ArrayBuffer
                const arrayBuffer = await file.arrayBuffer();
                const uint8Array = new Uint8Array(arrayBuffer);

                // Load the zip file for previews
                currentZip = await JSZip.loadAsync(arrayBuffer);
                currentFileName = file.name;

                // Set up timeout to terminate worker if processing takes too long
                workerTimeout = setTimeout(() => {
                    if (processingWorker) {
                        processingWorker.terminate();
                        initWorker(); // Reinitialize the worker
                    }
                    hideSpinner();
                    showError('Processing aborted: File took too long to analyze (>5 seconds). The file may be too large or complex.');
                }, 5000);

                // Send to worker for processing
                processingWorker.postMessage({
                    type: 'process',
                    data: { uint8Array }
                });

            } catch (e) {
                clearTimeout(workerTimeout);
                hideSpinner();
                showError('Error processing file: ' + e.message);
                console.error('Processing error:', e);
            }
        }

        function enhanceOutput(text) {
            let html = text;

            // Make file references clickable and hoverable
            // Match patterns like: texture.png, file.lua, icon.png, etc.
            html = html.replace(/([a-zA-Z0-9_\-\/]+\.(png|jpg|jpeg|gif|ogg|wav|mp3|lua|txt|animation))/g, 
                '<span class="file-ref" data-file="$1">$1</span>');

            // Make error line numbers hoverable
            // Match patterns like: [  74:69 ]
            html = html.replace(/\[\s*(\d+):(\d+)\s*\]/g, 
                '<span class="error-line" data-line="$1" data-col="$2">[$1:$2]</span>');

            // Match patterns with "in" context like: ... in "vulcan/vulcan.lua"
            html = html.replace(/in "([^"]+\.lua)"/g, 
                'in "<span class="file-ref" data-file="$1">$1</span>"');

            return html;
        }

        function attachTooltipHandlers() {
            // File reference tooltips
            document.querySelectorAll('.file-ref').forEach(el => {
                el.addEventListener('mouseenter', showFilePreview);
                el.addEventListener('mouseleave', hideTooltip);
                el.addEventListener('mousemove', positionTooltip);
                el.addEventListener('click', openFileModal);
            });

            // Error line tooltips
            document.querySelectorAll('.error-line').forEach(el => {
                el.addEventListener('mouseenter', showErrorContext);
                el.addEventListener('mouseleave', hideTooltip);
                el.addEventListener('mousemove', positionTooltip);
                el.addEventListener('click', openErrorInModal);
            });
        }

        async function showFilePreview(e) {
            const fileName = e.target.dataset.file;
            if (!currentZip || !fileName) return;

            try {
                const file = currentZip.file(fileName);
                if (!file) {
                    tooltip.innerHTML = `<div class="tooltip-error">File not found: ${fileName}</div>`;
                    tooltip.classList.add('visible');
                    return;
                }

                const ext = fileName.split('.').pop().toLowerCase();

                if (['png', 'jpg', 'jpeg', 'gif'].includes(ext)) {
                    // Image preview
                    const blob = await file.async('blob');
                    const url = URL.createObjectURL(blob);
                    tooltip.innerHTML = `
                        <div style="color:#d4d4d4"><strong>${fileName}</strong></div>
                        <img class="tooltip-image" src="${url}" onload="URL.revokeObjectURL('${url}')">
                    `;
                } else if (['lua', 'txt', 'animation'].includes(ext)) {
                    // Text file preview
                    const content = await file.async('text');
                    const allLines = content.split('\n');
                    const lines = allLines.slice(0, 20); // First 20 lines
                    let preview = '';
                    for (let i = 0; i < lines.length; i++) {
                        const lineNum = i + 1;
                        preview += `${lineNum.toString().padStart(4)}: ${escapeHtml(lines[i])}\n`;
                    }
                    tooltip.innerHTML = `
                        <div style="color:#d4d4d4"><strong>${fileName}</strong> (${lines.length} of ${allLines.length} lines shown)</div>
                        <div class="tooltip-text">${preview}</div>
                    `;
                } else {
                    // Other files
                    const size = (await file.async('arraybuffer')).byteLength;
                    tooltip.innerHTML = `
                        <div style="color:#d4d4d4"><strong>${fileName}</strong></div>
                        <div class="tooltip-text">Size: ${formatBytes(size)}</div>
                    `;
                }

                tooltip.classList.add('visible');
            } catch (err) {
                tooltip.innerHTML = `<div class="tooltip-error">Error loading file: ${err.message}</div>`;
                tooltip.classList.add('visible');
            }
        }

        async function showErrorContext(e) {
            const line = parseInt(e.target.dataset.line);
            const col = parseInt(e.target.dataset.col);
            
            // Find which file this error refers to by looking at context
            const errorText = e.target.closest('.output-content').textContent;
            const errorLines = errorText.split('\n');
            const errorIndex = errorLines.findIndex(l => l.includes(`[${line}:${col}]`));
            
            // Look for "... in" pattern - search both forward AND backward to catch grouped errors
            let fileName = null;
            
            // First search forward (up to 10 lines)
            for (let i = errorIndex; i < errorLines.length && i < errorIndex + 10; i++) {
                const match = errorLines[i].match(/in "([^"]+)"/);
                if (match) {
                    fileName = match[1];
                    break;
                }
            }
            
            // If not found forward, search backward (up to 10 lines) for the last file reference
            if (!fileName) {
                for (let i = errorIndex; i >= 0 && i > errorIndex - 10; i--) {
                    const match = errorLines[i].match(/in "([^"]+)"/);
                    if (match) {
                        fileName = match[1];
                        break;
                    }
                }
            }

            if (!fileName || !currentZip) {
                tooltip.innerHTML = `<div class="tooltip-text">Line ${line}, Column ${col}</div>`;
                tooltip.classList.add('visible');
                return;
            }

            try {
                const file = currentZip.file(fileName);
                if (!file) {
                    tooltip.innerHTML = `<div class="tooltip-error">File not found: ${fileName}</div>`;
                    tooltip.classList.add('visible');
                    return;
                }

                const content = await file.async('text');
                const lines = content.split('\n');
                
                // Show context around the error line (3 lines before and after)
                const startLine = Math.max(0, line - 4);
                const endLine = Math.min(lines.length, line + 3);
                const contextLines = lines.slice(startLine, endLine);
                
                let preview = '';
                for (let i = 0; i < contextLines.length; i++) {
                    const lineNum = startLine + i + 1;
                    const lineText = contextLines[i];
                    if (lineNum === line) {
                        // Highlight the error line and the specific character
                        const beforeError = escapeHtml(lineText.substring(0, col - 1));
                        const errorChar = lineText[col - 1] ? `<span class="error-char">${escapeHtml(lineText[col - 1])}</span>` : '';
                        const afterError = escapeHtml(lineText.substring(col));
                        preview += `<span style="background:#4a2424;color:#ff6b6b">${lineNum.toString().padStart(4)}: ${beforeError}${errorChar}${afterError}</span>\n`;
                    } else {
                        preview += `${lineNum.toString().padStart(4)}: ${escapeHtml(lineText)}\n`;
                    }
                }

                tooltip.innerHTML = `
                    <div style="color:#d4d4d4"><strong>${fileName}</strong> - Line ${line}</div>
                    <div class="tooltip-text">${preview}</div>
                `;
                tooltip.classList.add('visible');
            } catch (err) {
                tooltip.innerHTML = `<div class="tooltip-error">Error: ${err.message}</div>`;
                tooltip.classList.add('visible');
            }
        }

        function positionTooltip(e) {
            const margin = 15;
            let x = e.clientX + margin;
            let y = e.clientY + margin;

            // Keep tooltip within viewport
            const tooltipRect = tooltip.getBoundingClientRect();
            if (x + tooltipRect.width > window.innerWidth) {
                x = e.clientX - tooltipRect.width - margin;
            }
            if (y + tooltipRect.height > window.innerHeight) {
                y = e.clientY - tooltipRect.height - margin;
            }

            tooltip.style.left = x + 'px';
            tooltip.style.top = y + 'px';
        }

        function hideTooltip() {
            tooltip.classList.remove('visible');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        // Drag and drop handlers
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                processFile(files[0]);
            }
        });

        // Click to browse
        dropZone.addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                processFile(e.target.files[0]);
            }
        });

        // Modal functionality
        modalClose.addEventListener('click', () => {
            fileModal.classList.remove('visible');
        });

        fileModal.addEventListener('click', (e) => {
            if (e.target === fileModal) {
                fileModal.classList.remove('visible');
            }
        });

        async function openFileModal(e) {
            e.stopPropagation();
            const fileName = e.target.dataset.file;
            
            if (!currentZip) return;

            // Build file list
            buildFileBrowser();
            
            // Select and display the clicked file
            if (fileName) {
                await displayFileInModal(fileName);
            }
            
            fileModal.classList.add('visible');
        }

        async function openErrorInModal(e) {
            e.stopPropagation();
            const line = parseInt(e.target.dataset.line);
            const col = parseInt(e.target.dataset.col);
            
            if (!currentZip) return;

            // Find which file this error refers to
            const errorText = e.target.closest('.output-content').textContent;
            const errorLines = errorText.split('\n');
            const errorIndex = errorLines.findIndex(l => l.includes(`[${line}:${col}]`));
            
            let fileName = null;
            
            // Search forward for file reference
            for (let i = errorIndex; i < errorLines.length && i < errorIndex + 10; i++) {
                const match = errorLines[i].match(/in "([^"]+)"/);
                if (match) {
                    fileName = match[1];
                    break;
                }
            }
            
            // If not found forward, search backward
            if (!fileName) {
                for (let i = errorIndex; i >= 0 && i > errorIndex - 10; i--) {
                    const match = errorLines[i].match(/in "([^"]+)"/);
                    if (match) {
                        fileName = match[1];
                        break;
                    }
                }
            }

            if (!fileName) return;

            // Build file list
            buildFileBrowser();
            
            // Display the file and scroll to the error line
            await displayFileInModal(fileName, line);
            
            fileModal.classList.add('visible');
        }

        function buildFileBrowser() {
            fileBrowser.innerHTML = '';
            
            if (!currentZip) return;

            const fileList = [];
            currentZip.forEach((relativePath, file) => {
                fileList.push({ path: relativePath, isDir: file.dir });
            });

            // Sort: directories first, then alphabetically
            fileList.sort((a, b) => {
                if (a.isDir !== b.isDir) return a.isDir ? -1 : 1;
                return a.path.localeCompare(b.path);
            });

            fileList.forEach(({ path, isDir }) => {
                const item = document.createElement('div');
                item.className = isDir ? 'file-browser-item folder' : 'file-browser-item file';
                item.textContent = path;
                item.dataset.path = path;
                
                if (!isDir) {
                    item.addEventListener('click', async () => {
                        document.querySelectorAll('.file-browser-item').forEach(el => {
                            el.classList.remove('selected');
                        });
                        item.classList.add('selected');
                        await displayFileInModal(path);
                    });
                }
                
                fileBrowser.appendChild(item);
            });
        }

        async function displayFileInModal(filePath, scrollToLine = null) {
            if (!currentZip) return;

            const file = currentZip.file(filePath);
            if (!file) {
                filePreview.innerHTML = '<div class="file-preview-empty">File not found</div>';
                return;
            }

            const ext = filePath.split('.').pop().toLowerCase();

            try {
                if (['png', 'jpg', 'jpeg', 'gif'].includes(ext)) {
                    // Image preview
                    const blob = await file.async('blob');
                    const url = URL.createObjectURL(blob);
                    filePreview.innerHTML = `
                        <div style="text-align:center">
                            <h3 style="color:#333;margin-bottom:20px">${filePath}</h3>
                            <img class="file-preview-image" src="${url}" onload="URL.revokeObjectURL('${url}')">
                        </div>
                    `;
                } else if (['lua', 'txt', 'animation', 'md', 'json', 'xml', 'js', 'ts', 'py', 'sh', 'yaml', 'yml'].includes(ext)) {
                    // Text file preview with syntax highlighting
                    const content = await file.async('text');
                    
                    // Detect language for highlighting
                    const languageMap = {
                        'lua': 'lua',
                        'js': 'javascript',
                        'ts': 'typescript',
                        'json': 'json',
                        'xml': 'xml',
                        'md': 'markdown',
                        'py': 'python',
                        'sh': 'bash',
                        'yaml': 'yaml',
                        'yml': 'yaml',
                        'txt': 'plaintext',
                        'animation': 'plaintext'
                    };
                    
                    const language = languageMap[ext] || 'plaintext';
                    
                    // Apply syntax highlighting
                    const highlighted = hljs.highlight(content, { language }).value;
                    
                    // Add line numbers and highlight error line if specified
                    const lines = highlighted.split('\n');
                    let numberedContent = '';
                    lines.forEach((line, i) => {
                        const lineNum = i + 1;
                        const lineId = `line-${lineNum}`;
                        if (scrollToLine && lineNum === scrollToLine) {
                            numberedContent += `<div id="${lineId}" style="background:#4a2424;padding:2px 0">${lineNum.toString().padStart(4)}: ${line}</div>`;
                        } else {
                            numberedContent += `${lineNum.toString().padStart(4)}: ${line}\n`;
                        }
                    });
                    
                    filePreview.innerHTML = `
                        <div>
                            <h3 style="color:#333;margin-bottom:10px">${filePath}</h3>
                            <div class="file-preview-content"><code class="hljs">${numberedContent}</code></div>
                        </div>
                    `;
                    
                    // Scroll to the error line if specified
                    if (scrollToLine) {
                        setTimeout(() => {
                            const lineElement = document.getElementById(`line-${scrollToLine}`);
                            if (lineElement) {
                                lineElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }
                        }, 100);
                    }
                } else {
                    // Binary or unknown file
                    const size = (await file.async('arraybuffer')).byteLength;
                    filePreview.innerHTML = `
                        <div class="file-preview-empty">
                            <h3 style="color:#333">${filePath}</h3>
                            <p>Binary file (${formatBytes(size)})</p>
                            <p>Preview not available</p>
                        </div>
                    `;
                }
            } catch (err) {
                filePreview.innerHTML = `<div class="file-preview-empty">Error loading file: ${err.message}</div>`;
            }
        }

        // Initialize on load
        initWorker();
    </script>
</body>
</html>
